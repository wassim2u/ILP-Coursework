package uk.ac.ed.inf.aqmaps;


import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.mapbox.geojson.Point;

public class Drone {
	private Point startingPoint; //The start point of a drone. The robot must end its journey  as close as possible back to these coordinates.
	private Sensor[] listOfSensors; //The list of sensors to visit. We will always need to visit all 33 sensors.
	private int predictedMoveCount = 0; //Keeps track of the number of moves it will make. - Updated after DroneControl generates a path.
	private int numberOfMovesTaken = 0; //Keeps track of the number of moves it made. - Used for logging flight path and to emulate drone movement

	private final int MAXIMUM_MOVES = 150; //The flight path of a drone is at most 150 moves in total. 
	private NoFlyZone restrictedAreas;
	private int[] droneTourSpots;
	private int firstSensorInTour = 1; 
	private List<Point> droneCompletePath;
	private List<Integer> droneCompleteDirections;
	
	private boolean createNewFile = true;
	
	
	
	public Drone(Point start, Sensor[] sensors, NoFlyZone offLimitZones) {
		startingPoint = start;
		listOfSensors = sensors;
		restrictedAreas = offLimitZones;
		
		List<Point> sensorPoints = getAllSensorPoints();

		//Given the starting point, the drone should find the estimated best route it should take
		var routeAlgorithm = new RoutePlanner(start, sensorPoints);
		//Calculate the best path and return it, includes the starting point which is at index 0.
		droneTourSpots =  routeAlgorithm.generateRoute();
		droneCompletePath = new ArrayList<Point>();
		droneCompleteDirections = new ArrayList<Integer>();
	}

	//TODO: Handle null cases - when we dont have any path returned (For example - Exceeded Number of moves) OR When path length < 2;
	public List<Point> returnCompletePath(boolean recordFlight){
		//Initialise our droneControl class to start navigating around obstacles 
		//to get to each destination point (whether sensor or final end position which is our starting point).
		var droneController = new DronePathing(this);
		//At the start calculate the path from start point to first sensor
		registerNewPathingInfo(droneController, startingPoint, getSensorCoordinatesInTour(firstSensorInTour), firstSensorInTour, recordFlight);
		var droneNewPoint = droneCompletePath.get(droneCompletePath.size()-1);
		for (int tourNumber = 2; tourNumber < droneTourSpots.length; tourNumber++) {
			registerNewPathingInfo(droneController, droneNewPoint, getSensorCoordinatesInTour(tourNumber), tourNumber, recordFlight);
			droneNewPoint = droneCompletePath.get(droneCompletePath.size()-1);
		}
		//At the end, calculate the final path from the last sensor on our tour route generated by RoutePlanner algorithm to the start point.
		registerNewPathingInfo(droneController, droneNewPoint, startingPoint, droneTourSpots.length, recordFlight);
		return droneCompletePath;
	}
	
	
	//TourNumber == 34 represents the starting point, which is also our end goal as we are interested in going back to the starting point at the end of our sensor tour.
	private void registerNewPathingInfo(DronePathing droneController,Point pointA, Point pointB, int tourNumber, boolean recordFlight) {
		droneController.generatePath(pointA, pointB);
		List<Point> path = droneController.getPathOfCurrentMovement(); 	//TODO: Handle null errors here

		var direction = droneController.getDirectionAnglesOfCurrentPathing();
		for (int pathNumber=0; pathNumber< path.size(); pathNumber++) {
			
			droneCompletePath.add(path.get(pathNumber));
			droneCompleteDirections.add(direction.get(pathNumber));
			
			if (recordFlight && pathNumber > 0) {
				numberOfMovesTaken+= 1;
				//Record sensor if we have reached the next destination and the tourNumber is not zero. 
				if (tourNumber!=droneTourSpots.length && pathNumber == path.size()-1) {
					var sensorInRange = getSensorInTour(tourNumber);
					recordFlightPath(numberOfMovesTaken,path.get(pathNumber-1),path.get(pathNumber), direction.get(pathNumber-1),sensorInRange.getw3wLocation());
				}
				else {
					recordFlightPath(numberOfMovesTaken,path.get(pathNumber-1),path.get(pathNumber), direction.get(pathNumber-1),null);
				}
			}
		}
		
		if (tourNumber != droneTourSpots.length) {
			readSensor(getSensorInTour(tourNumber)); 
		}
		
		
		

	}
	
	

	public Sensor getSensorInTour(int currentTourIndex) {
		var sensorNumber = droneTourSpots[currentTourIndex]-1; //We subtract by 1 to account for the added starting point to our tour, which shifted our sensor numbers by 1. 
		return listOfSensors[sensorNumber]; 
	}
	
	public Point getSensorCoordinatesInTour(int currentTourIndex) {
		return getSensorInTour(currentTourIndex).locateSensorCoordinates();
	}
	
	public List<Point> getAllSensorPoints(){
		var sensorPoints = new ArrayList<Point>(listOfSensors.length);
		for (Sensor sensor: listOfSensors) {
			sensorPoints.add(sensor.locateSensorCoordinates());
		}
		return sensorPoints;
	}
	
	
	//TODO: Check null exception for battery? What do we use sensor readings for?
	public Float readSensor(Sensor sensor) {
		sensor.setVisitedStatus(true); //Report that sensor has been visited

		if (sensor.getBattery() < 10) {
			System.out.println("Current Sensor is low on battery: " + sensor.getBattery() + ". Location: " +sensor.getw3wLocation() + " - Flagged to be replaced.");
			sensor.setReplacementStatus(true); //Report that sensor needs to be replaced.
			return null;
		}
		else {
			return sensor.getReading();

		}
	}
	
	

	
	public void recordFlightPath(int moveCount, Point pointOnPath, Point nextPointOnPath, int directionAngle, String sensorLocation) {
		//Get coordinates information
		var lng = pointOnPath.longitude() ; var lat = pointOnPath.latitude();
		var nextLng = nextPointOnPath.longitude() ; var nextLat = nextPointOnPath.latitude();
		//Concatenate text to be added to the text file.
		var text = moveCount + "," + lng + "," + lat + "," + directionAngle + "," + nextLng + "," + nextLat + "," + sensorLocation + "\n";
		//Get date information for the filename.
		var year =App.getYearString();
		var month =App.getMonthString();
		var day =App.getDayString();
		var filename = "flightpath-" + day + "-" + month + "-" + year+ ".txt";
		try {
			//For the first iteration, a new file will be created and the text will be added to it. 
			//After that, new calls to the function to record flight path will result in appending new lines of text to it.
			FileUtilities.createOrAppendToFile(text, filename, createNewFile);
			//After the first creation of file, set file to be false in order not to overwrite old changes.
			setNewFileCreationStatus(false); 	

		}
		catch(IOException e) {
			e.printStackTrace();
			System.exit(-1); //Unsuccessful termination of program
		}
	}
	

	public void addPredictedMoveCount(int moves) {
		predictedMoveCount = predictedMoveCount + moves;
	}
	
	

	
	public int getCurrentNumberOfMoves() {
		return numberOfMovesTaken;
	}
	
	
	public int getMaximumNumberOfAllowedMoves() {
		return MAXIMUM_MOVES;
	}
	
	public NoFlyZone getOffLimitZones() {
		return restrictedAreas;
	}
	
	public List<Integer> getCompleteDirections(){
		return droneCompleteDirections;
	}
	
	private void setNewFileCreationStatus(boolean create) {
		this.createNewFile = create;
	}
	
	
}
