package uk.ac.ed.inf.aqmaps;


import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.mapbox.geojson.Point;

/**
 * The class represents the attributes of a drone. 
 * Its main responsibility lies in initiating all events involved in the drone life process, from initiating the scheduling of pathing that the drone needs to take,
 * reading the sensor information when it is within range, and logging its flight path journey if needed.
 * Note that this drone class does not handle path generation algorithm, but it creates new objects of types RoutePlanner and DronePathing which returns this information back to the drone.
 */
public class Drone {
	/** The start point of a drone. The robot must end its journey  as close as possible back to these coordinates. */
	private Point startingPoint; 
	/** The list of sensors to visit.*/ 
	private Sensor[] listOfSensors; 
	/** Keeps track of the number of moves it will make.  Updated after DronePathing generates a path from one point to another. */
	private int predictedMoveCount = 0; 
	/** Keeps track of the number of moves it made. Used for logging flight path and to emulate drone movement */
	private int numberOfMovesTaken = 0; 
	/** The maximim poves that a drone can take. */
	private final int MAXIMUM_MOVES = 150;
	/** Holds information on the restricted areas that it cannot go to, including the knowlegde of the confinement area. */
	private NoFlyZone restrictedAreas;
	/**
	 *  Initialised when a Drone object is made. Represents the pathing scheduled from RoutePlanner object, with the value representing a mapping to the sensor number in the listOfSensors array.
	 *  I.e) The index represents the flight number in order (with 0 being the departure at the starting point). The value 5 at an index i signifies that the drone gets in range to sensor numbered 5 in our int[] listOfSensors array at flight number i.
	 */
	private int[] droneTourSpots;
	/** The pathing scheduled from RoutePlanner object has the first sensor to visit at Flight number 1 in the droneTourSpots array, with 0 being the starting position of the drone when the program is started.  */
	private int firstSensorInTour = 1; 
	/** The pathing successfully taken by the drone as it emulates movement from one point to another.*/
	private List<Point> droneCompletePath;
	/** Represents the direction of departure (0 degrees being East moving counterclockwise in multiples of 10) when the drone successfully emulates the pathing from one point to another.*/
	private List<Integer> droneCompleteDirections;
	/** For every life cycle of a program, used for the creation of a new file representing the flight path recorded. */
	private boolean createNewFile = true;
	/** The range of the drone's receiver in degrees */
	private double receiverRange = 0.0002;
	
	
	
	public Drone(Point start, Sensor[] sensors, NoFlyZone offLimitZones) {
		startingPoint = start;
		listOfSensors = sensors;
		restrictedAreas = offLimitZones;
		
		List<Point> sensorPoints = getAllSensorPoints();

		//Given the starting point, the drone should find the estimated best route it should take
		var routeAlgorithm = new RoutePlanner(start, sensorPoints);
		//Calculate the best path and return it, includes the starting point which is at index 0.
		droneTourSpots =  routeAlgorithm.generateRoute();
		droneCompletePath = new ArrayList<Point>();
		droneCompleteDirections = new ArrayList<Integer>();
	}

	
	
	/**
	 * Finds the complete pathing at the end of the drone lifecycle with the schedule of flights returned by RoutePlanner.
	 * @param recordFlight Boolean value to signal the drone whether there is a need to record the flight paths taken or not. 
	 * @return a list of points representing the full pathing taken by the drone at the end of its lifecycle
	 */
	public List<Point> returnCompletePath(boolean recordFlight){
		System.out.println("Currently navigating the best possible paths from the travel plan while avoiding obstacles...");
		//Initialise our droneControl class to start navigating around obstacles 
		//to get to each destination point (whether sensor or final end position which is our starting point).
		var droneController = new DronePathing(this);
		//At the start calculate the path from start point to first sensor
		registerNewPathingInfo(droneController, startingPoint, getSensorCoordinatesInTour(firstSensorInTour), firstSensorInTour, recordFlight);
		var droneNewPoint = droneCompletePath.get(droneCompletePath.size()-1);
		for (int tourNumber = 2; tourNumber < droneTourSpots.length; tourNumber++) {
			registerNewPathingInfo(droneController, droneNewPoint, getSensorCoordinatesInTour(tourNumber), tourNumber, recordFlight);
			droneNewPoint = droneCompletePath.get(droneCompletePath.size()-1);
		}
		//At the end, calculate the final path from the last sensor on our tour route generated by RoutePlanner algorithm to the start point.
		registerNewPathingInfo(droneController, droneNewPoint, startingPoint, droneTourSpots.length, recordFlight);
    	System.out.println("Drone Navigation Complete!");

		return droneCompletePath;
	}
	
	
	/**
	 * Updates the internal values of the drone as it emulates movement from pointA to the next destination pointB. 
	 * @param droneController The object that handles the pathfinding problem from one point to another while avoiding the no fly zones. To be used to generate a path from pointA to pointB.
	 * @param pointA The departure from the first point.
	 * @param pointB The next point destination.
	 * @param tourNumber The current flight number in our complete pathing.
	 * @param recordFlight Set to True if logging values are required.
	 */
	private void registerNewPathingInfo(DronePathing droneController,Point pointA, Point pointB, int tourNumber, boolean recordFlight) {
		//TourNumber == 34 represents the starting point, which is also our end goal as we are interested in going back to the starting point at the end of our sensor tour.
		droneController.generatePathAStar(pointA, pointB);
		List<Point> path = droneController.getPathOfCurrentMovement(); 
		//If no path has been found
		if (path != null) {
			var direction = droneController.getDirectionAnglesOfCurrentPathing();
			for (int pathNumber=0; pathNumber< path.size(); pathNumber++) {
				
				droneCompletePath.add(path.get(pathNumber));
				droneCompleteDirections.add(direction.get(pathNumber));
				
				if (recordFlight && pathNumber > 0) {
					numberOfMovesTaken+= 1;
					//Record sensor if we have reached the next destination and the tourNumber is not zero. 
					if (tourNumber!=droneTourSpots.length && pathNumber == path.size()-1) {
						var sensorInRange = getSensorInTour(tourNumber);
						recordFlightPath(numberOfMovesTaken,path.get(pathNumber-1),path.get(pathNumber), direction.get(pathNumber-1),sensorInRange.getw3wLocation());
					}
					else {
						recordFlightPath(numberOfMovesTaken,path.get(pathNumber-1),path.get(pathNumber), direction.get(pathNumber-1),null);
					}
				}
			}
			
			if (tourNumber != droneTourSpots.length) {
				readSensor(getSensorInTour(tourNumber)); 
			}
		}
		else {
			System.out.println("**Couldn't find path from these points");
			System.out.println("Point A: (" + pointA.latitude() + "," + pointA.longitude() + ")"  );
			System.out.println("Point B: (" + pointB.latitude() + "," + pointB.longitude() + ")"  );
			System.out.println("Tour Number generated by RoutePlanner: " + tourNumber );


		}
		
		
		

	}
	
	
	/**
	 * Returns object of type Sensor at the specified flight number in the journey from our list of sensors. The function allows us to map the requried flight number to the corresponding sensor.
	 * @param currentTourIndex The current flight number
	 * @return The specified sensor needed. 
	 */
	public Sensor getSensorInTour(int currentTourIndex) {
		var sensorNumber = droneTourSpots[currentTourIndex]-1; //We subtract by 1 to account for the added starting point to our tour, which shifted our sensor numbers by 1. 
		return listOfSensors[sensorNumber]; 
	}
	
	/**
	 * Finds the point coordinates of the sensor given a specified flight number that corresponds to the sensor at a particular spot on the journey in our flight path.
	 * @param currentTourIndex The current flight number
	 * @return The Point coordinates of the specified sensor needed
	 */
	public Point getSensorCoordinatesInTour(int currentTourIndex) {
		return getSensorInTour(currentTourIndex).locateSensorCoordinates();
	}
	
	/**
	 * Takes the information we know about our list of sensors that need to be visited (parsed from the webserver) and returns a list of their point coordinates on the map
	 * @return The list of point coordinates for all the sensors.
	 */
	public List<Point> getAllSensorPoints(){
		var sensorPoints = new ArrayList<Point>(listOfSensors.length);
		for (Sensor sensor: listOfSensors) {
			sensorPoints.add(sensor.locateSensorCoordinates());
		}
		return sensorPoints;
	}
	
	
	/**
	 * Emulates the reading of a sensor by communicating with the sensor object and mark it as visited. If the battery is less than 10, report as malfunctioning.
	 * @param sensor The Sensor the drone is in range with and can take readings from if possible.
	 * @return Returns the reading returned by the sensor. Return null if the battery is low (less than 10).
	 */
	public String readSensor(Sensor sensor) {
		sensor.setVisitedStatus(true); //Report that sensor has been visited

		if (sensor.getBattery() < 10) {
			System.out.println("* Current Sensor is low on battery: " + sensor.getBattery() + ". Location: " +sensor.getw3wLocation() + " - Flagged to be replaced.");
			sensor.setReplacementStatus(true); //Report that sensor needs to be replaced.
			return null;
		}
		else {
			return sensor.getReading();

		}
	}
	
	

	/**
	 * Records the flight journey path in a text file
	 * @param moveCount Number of moves
	 * @param pointOnPath The point on a path
	 * @param nextPointOnPath the next close point in the path
	 * @param directionAngle the angle in which the drone moved from pointOnPath
	 * @param sensorLocation the what3words location of the sensor
	 */
	public void recordFlightPath(int moveCount, Point pointOnPath, Point nextPointOnPath, int directionAngle, String sensorLocation) {
		//Get coordinates information
		var lng = pointOnPath.longitude() ; var lat = pointOnPath.latitude();
		var nextLng = nextPointOnPath.longitude() ; var nextLat = nextPointOnPath.latitude();
		//Concatenate text to be added to the text file.
		var text = moveCount + "," + lng + "," + lat + "," + directionAngle + "," + nextLng + "," + nextLat + "," + sensorLocation + "\n";
		//Get date information for the filename.
		var year =App.getYearString();
		var month =App.getMonthString();
		var day =App.getDayString();
		var extensionType = "txt";
		var filename = "flightpath-" + day + "-" + month + "-" + year;
		try {
			//For the first iteration, a new file will be created and the text will be added to it. 
			//After that, new calls to the function to record flight path will result in appending new lines of text to it.
			FileUtilities.createOrAppendToFile(text, filename, extensionType, createNewFile);
			//After the first creation of file, set file to be false in order not to overwrite old changes.
			setNewFileCreationStatus(false); 	

		}
		catch(IOException e) {
			e.printStackTrace();
			System.exit(-1); //Unsuccessful termination of program
		}
	}
	

	/**
	 * Update the predictedMoveCount, signifying the number of moves the drone will make after it schedules a pathing. 
	 * @param moves The number of moves made calculated at the end of the path generation segment of DronePathing. 
	 */
	public void addPredictedMoveCount(int moves) {
		predictedMoveCount = predictedMoveCount + moves;
	}
	
	

	
	public int getCurrentNumberOfMoves() {
		return numberOfMovesTaken;
	}
	
	
	public int getMaximumNumberOfAllowedMoves() {
		return MAXIMUM_MOVES;
	}
	
	public NoFlyZone getOffLimitZones() {
		return restrictedAreas;
	}
	
	
	public List<Integer> getCompleteDirections(){
		return droneCompleteDirections;
	}
	
	public double getReadingRange() {
		return receiverRange ;
	}
	private void setNewFileCreationStatus(boolean create) {
		this.createNewFile = create;
	}
	
	
}
