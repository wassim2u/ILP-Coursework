package uk.ac.ed.inf.aqmaps;


import java.util.ArrayList;
import java.util.List;

import com.mapbox.geojson.Point;

public class Drone {
	private Point startingPoint; //The start point of a drone. The robot must end its journey  as close as possible back to these coordinates.
	private Sensor[] listOfSensors; //The list of sensors to visit. We will always need to visit all 33 sensors.
	private int moveCount = 0; //Keeps track of the number of moves it made.
	
	private final double MOVE_LENGTH = 0.0003; //Length of a move in degrees
	private final int MAXIMUM_MOVES = 150; //The flight path of a drone is at most 150 moves in total. 
	private NoFlyZone restrictedAreas;
	private int[] droneTourSpots;
	private List<Point> droneCompletePath;
	
	
	public Drone(Point start, Sensor[] sensors, NoFlyZone noZones) {
		startingPoint = start;
		listOfSensors = sensors;
		restrictedAreas = noZones;
		//Given the starting point, the drone should find the estimated best route it should take
		var routeAlgorithm = new RoutePlanner(start, sensors);
		//Calculate the best path and return it, includes the starting point which is at index 0.
		droneTourSpots =  routeAlgorithm.generateRoute();
		droneCompletePath = new ArrayList<Point>();
	}

	public List<Point> returnCompletePath(){
		//Initialise our droneControl class to start navigating around obstacles 
		//to get to each destination point (whether sensor or final end position which is our starting point).
		var droneController = new DroneControl(this);
		//At the start calculate the path from start point to first sensor
		droneController.generatePath(startingPoint, getSensorCoordinatesInTour(1));
		var startPath = droneController.getPathOfCurrentMovement();
		for (Point point: startPath) {
			droneCompletePath.addAll(startPath);
		}
		System.out.println("Hello");
		//Read sensor values
//		this.readSensor(listOfSensors[0]);
		
		for (int tourNumber = 2; tourNumber < droneTourSpots.length; tourNumber++) {
			droneController.generatePath(getSensorCoordinatesInTour(tourNumber-1), getSensorCoordinatesInTour(tourNumber));
			var path = droneController.getPathOfCurrentMovement();
			droneCompletePath.addAll(path);
			Sensor sensorInRange = getSensorInTour(tourNumber);
			
		}
		//At the end, calculate the final path from the last sensor on our tour route generated by RoutePlanner algorithm to the start point.
		droneController.generatePath(getSensorCoordinatesInTour(droneTourSpots.length-1), startingPoint);
		var endPath = droneController.getPathOfCurrentMovement();
		droneCompletePath.addAll(endPath);
		
		return droneCompletePath;
	}
	

	public Sensor getSensorInTour(int currentTourIndex) {
		var sensorNumber = droneTourSpots[currentTourIndex]-1; //We subtract by 1 to account for the added starting point to our tour, which shifted our sensor numbers by 1. 
		return listOfSensors[droneTourSpots[currentTourIndex]-1]; 
	}
	
	public Point getSensorCoordinatesInTour(int currentTourIndex) {
		return getSensorInTour(currentTourIndex).locateSensorCoordinates();
	}
	
	
	//TODO: Check null exception for battery? 
	public Float readSensor(Sensor sensor) {
		if (sensor.getBattery() < 10) {
			System.out.println("Current Sensor is low on battery: " + sensor.getBattery() + ". Flagged to be replaced.");
			sensor.setReplacementStatus(true); //Report that sensor needs to be replaced.
			return null;
		}
		else {
			return sensor.getReading();
		}
	}
	
	
	
	
	
	public void addMoveCount(int moves) {
		moveCount = moveCount + moves;
	}
	
	public void recordNewDronePath(List<Point> path, List<Integer> direction, int tourNumberWithTargetSensor, boolean recordVisits) {
		for (int pathNumber=1; pathNumber < path.size(); pathNumber++) {
			var pointA = path.get(pathNumber-1);
			var pointB = path.get(pathNumber);
			droneCompletePath.add(pointA);
			droneCompletePath.add(pointB);
			if (recordVisits) {
				int angleFromPointA = direction.get(pathNumber-1);
				String sensorLocation = getSensorInTour(tourNumberWithTargetSensor).getw3wLocation();
				recordDronePath(pointA,pointB,angleFromPointA,sensorLocation);
			}

		}
	}
	
	public void recordDronePath(Point startPoint, Point targetPoint, int directionAngle, String sensorLocation) {
		
	}

	
	public int getNumberOfMoves() {
		return moveCount;
	}
	
	
	public int getMaximumNumberOfAllowedMoves() {
		return MAXIMUM_MOVES;
	}
	
	public NoFlyZone getOffLimitZones() {
		return restrictedAreas;
	}
	
	
}
