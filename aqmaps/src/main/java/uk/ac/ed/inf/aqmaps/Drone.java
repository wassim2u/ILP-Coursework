package uk.ac.ed.inf.aqmaps;


import java.util.ArrayList;
import java.util.List;

import com.mapbox.geojson.Point;

public class Drone {
	private Point startingPoint; //The start point of a drone. The robot must end its journey  as close as possible back to these coordinates.
	private Sensor[] listOfSensors; //The list of sensors to visit. We will always need to visit all 33 sensors.
	private int moveCount = 0; //Keeps track of the number of moves it made.
	
	private final double MOVE_LENGTH = 0.0003; //Length of a move in degrees
	private final int MAXIMUM_MOVES = 150; //The flight path of a drone is at most 150 moves in total. 
	private NoFlyZone restrictedAreas;
	private int[] droneTourSpots;
	private int firstSensorInTour = 1; 
	private List<Point> droneCompletePath;
	private List<Integer> droneCompleteDirections;

	
	
	public Drone(Point start, Sensor[] sensors, NoFlyZone noZones) {
		startingPoint = start;
		listOfSensors = sensors;
		restrictedAreas = noZones;
		//Given the starting point, the drone should find the estimated best route it should take
		var routeAlgorithm = new RoutePlanner(start, sensors);
		//Calculate the best path and return it, includes the starting point which is at index 0.
		droneTourSpots =  routeAlgorithm.generateRoute();
		droneCompletePath = new ArrayList<Point>();
		droneCompleteDirections = new ArrayList<Integer>();
	}

	public List<Point> returnCompletePath(){
		//Initialise our droneControl class to start navigating around obstacles 
		//to get to each destination point (whether sensor or final end position which is our starting point).
		var droneController = new DroneControl(this);
		//At the start calculate the path from start point to first sensor
		droneController.generatePath(startingPoint, getSensorCoordinatesInTour(firstSensorInTour));
		var startPath = droneController.getPathOfCurrentMovement();
		var startDirections = droneController.getDirectionAnglesOfCurrentPathing();
		registerNewPathingInfo(startPath,startDirections);
		readSensor(getSensorInTour(firstSensorInTour));

		
		var droneNewPoint = startPath.get(startPath.size()-1);
		for (int tourNumber = 2; tourNumber < droneTourSpots.length; tourNumber++) {
			droneController.generatePath(droneNewPoint, getSensorCoordinatesInTour(tourNumber));
			var path = droneController.getPathOfCurrentMovement();
			var directions = droneController.getDirectionAnglesOfCurrentPathing();
			registerNewPathingInfo(path,directions);
			readSensor(getSensorInTour(tourNumber));

			
			droneNewPoint = path.get(path.size()-1);
			

		}
		//At the end, calculate the final path from the last sensor on our tour route generated by RoutePlanner algorithm to the start point.
		droneController.generatePath(droneNewPoint, startingPoint);
		var endPath = droneController.getPathOfCurrentMovement();
		var endDirections = droneController.getDirectionAnglesOfCurrentPathing();
		registerNewPathingInfo(endPath,endDirections);


		return droneCompletePath;
	}
	

	public Sensor getSensorInTour(int currentTourIndex) {
		var sensorNumber = droneTourSpots[currentTourIndex]-1; //We subtract by 1 to account for the added starting point to our tour, which shifted our sensor numbers by 1. 
		return listOfSensors[sensorNumber]; 
	}
	
	public Point getSensorCoordinatesInTour(int currentTourIndex) {
		return getSensorInTour(currentTourIndex).locateSensorCoordinates();
	}
	
	
	//TODO: Check null exception for battery? 
	public Float readSensor(Sensor sensor) {
		sensor.setVisitedStatus(true); //Report that sensor has been visited

		if (sensor.getBattery() < 10) {
			System.out.println("Current Sensor is low on battery: " + sensor.getBattery() + ". Flagged to be replaced.");
			sensor.setReplacementStatus(true); //Report that sensor needs to be replaced.
			return null;
		}
		else {
			return sensor.getReading();

		}
	}
	
	
	
	
	
	public void addMoveCount(int moves) {
		moveCount = moveCount + moves;
	}
	
	public void registerNewDronePath(List<Point> path, List<Integer> direction, int targetSensorTourNumber, boolean recordVisits) {
		for (int pathNumber=1; pathNumber < path.size(); pathNumber++) {
			var pointA = path.get(pathNumber-1);
			var pointB = path.get(pathNumber);
			droneCompletePath.add(pointA);
			droneCompletePath.add(pointB);
			
			if (recordVisits) {
				int angleFromPointA = direction.get(pathNumber-1);
				String sensorLocation = getSensorInTour(targetSensorTourNumber).getw3wLocation();
				recordFlightPath(pointA,pointB,angleFromPointA,sensorLocation);
			}

		}
	}
	
	private void registerNewPathingInfo(List<Point> path, List<Integer> direction) {
		droneCompletePath.addAll(path);
		droneCompleteDirections.addAll(direction);
	}
	
	public void recordFlightPath(Point startPoint, Point targetPoint, int directionAngle, String sensorLocation) {
		
	}

	
	public int getNumberOfMoves() {
		return moveCount;
	}
	
	
	public int getMaximumNumberOfAllowedMoves() {
		return MAXIMUM_MOVES;
	}
	
	public NoFlyZone getOffLimitZones() {
		return restrictedAreas;
	}
	
	
}
